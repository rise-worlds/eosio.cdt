// Declares clang::SyntaxOnlyAction.
#include "clang/Frontend/FrontendActions.h"
#include "clang/Tooling/CommonOptionsParser.h"
#include "clang/Tooling/Tooling.h"
#include "clang/ASTMatchers/ASTMatchers.h"
#include "clang/ASTMatchers/ASTMatchFinder.h"
#include "clang/AST/DeclCXX.h"
#include "clang/AST/DeclTemplate.h"
#include "clang/AST/Expr.h"
#include "clang/Basic/Builtins.h"
#include "clang/Rewrite/Core/Rewriter.h"
#include "clang/Rewrite/Frontend/Rewriters.h"
#include "llvm/Support/FileSystem.h"

#include <eosio/abigen.hpp>
#include <eosio/codegen.hpp>
// Declares llvm::cl::extrahelp.
#include "llvm/Support/CommandLine.h"
#include <set>
#include <sstream>

using namespace clang::tooling;
using namespace clang::ast_matchers;
using namespace llvm;
using namespace eosio;
using namespace eosio::cdt;

namespace eosio { namespace cdt {
   DeclarationMatcher function_decl_matcher = cxxMethodDecl().bind("eosio_tool");
   DeclarationMatcher record_decl_matcher   = cxxRecordDecl().bind("eosio_tool");
   DeclarationMatcher typedef_decl_matcher  = typedefDecl().bind("eosio_tool");
   auto               class_tmp_matcher     = classTemplateSpecializationDecl().bind("eosio_tool");
   abigen_exception  abigen_ex;
   codegen_exception codegen_ex;
   Rewriter          codegen_rewriter;
   CompilerInstance* codegen_ci;
   std::set<FileID>  codegen_rewritten;

   abigen& get_abigen_ref() {
      static abigen ag;
      return ag;
   }

   class EosioMethodMatcher : public MatchFinder::MatchCallback {
      public:
         virtual void run( const MatchFinder::MatchResult& res ) {
            if (const clang::CXXMethodDecl* decl = res.Nodes.getNodeAs<clang::CXXMethodDecl>("eosio_tool")->getCanonicalDecl()) {
               abi abi;
               if (decl->isEosioAction() && abigen::is_eosio_contract(decl, get_abigen_ref().get_contract_name())) {
                  get_abigen_ref().add_struct(decl);
                  get_abigen_ref().add_action(decl);
                  auto params = decl->parameters();
                  for (auto param : params) {
                     get_abigen_ref().add_type(param->getType());
                  }
               }
            }
         }
   };

   class EosioRecordMatcher : public MatchFinder::MatchCallback {
      public:
         bool has_added_clauses = false;
         virtual void run( const MatchFinder::MatchResult& res ) {
            if (const clang::CXXRecordDecl* decl = res.Nodes.getNodeAs<clang::CXXRecordDecl>("eosio_tool")) {
               if (!has_added_clauses) {
                  get_abigen_ref().add_clauses(get_abigen_ref().parse_clauses());
                  get_abigen_ref().add_contracts(get_abigen_ref().parse_contracts());
                  has_added_clauses = true;
               }
               if (decl->isEosioAction() && abigen::is_eosio_contract(decl, get_abigen_ref().get_contract_name())) {
                  get_abigen_ref().add_struct(decl);
                  get_abigen_ref().add_action(decl);
                  for (auto field : decl->fields()) {
                     get_abigen_ref().add_type( field->getType() );
                  }
               }
               if (decl->isEosioTable() && abigen::is_eosio_contract(decl, get_abigen_ref().get_contract_name())) {
                  get_abigen_ref().add_struct(decl);
                  get_abigen_ref().add_table(decl);
                  for (auto field : decl->fields())
                     get_abigen_ref().add_type( field->getType() );
               }
            }

            if (const clang::ClassTemplateSpecializationDecl* decl = res.Nodes.getNodeAs<clang::ClassTemplateSpecializationDecl>("eosio_tool")) {
               if ( decl->getName() == "multi_index" ) {
                  get_abigen_ref().add_table(decl->getTemplateArgs()[0].getAsIntegral().getExtValue(),
                                          (clang::CXXRecordDecl*)((clang::RecordType*)decl->getTemplateArgs()[1].getAsType().getTypePtr())->getDecl());
               }
            }
         }
   };
}} // ns eosio::cdt

int main(int argc, const char **argv) {

   cl::SetVersionPrinter([](llvm::raw_ostream& os) {
        os << "eosio-abigen version " << "${VERSION_FULL}" << "\n";
  });
   cl::OptionCategory cat("eosio-abigen", "generates an abi from C++ project input");

   cl::opt<std::string> abidir(
    "output",
    cl::desc("Set the output filename and fullpath"),
    cl::Required,
    cl::cat(cat));
   cl::opt<std::string> contract_name(
    "contract",
    cl::desc("Set the contract name"),
    cl::Required,
    cl::cat(cat));
   cl::opt<bool> def(
    "default",
    cl::desc("<ignored>"),
    cl::Hidden,
    cl::cat(cat));
   cl::opt<bool> codegen(
    "codegen",
    cl::desc("<ignored>"),
    cl::Hidden,
    cl::cat(cat));
   cl::opt<bool> codegen_only(
    "codegen-only",
    cl::desc("<ignored>"),
    cl::Hidden,
    cl::cat(cat));

   cl::list<std::string> resource_paths(
     "R",
     cl::desc("Add a resource path for inclusion"),
     cl::cat(cat),
     cl::Prefix,
     cl::ZeroOrMore);
   
   std::vector<std::string> options;
   for (size_t i=0; i < argc; i++) {
      options.push_back(argv[i]);
   }
   bool has_dash_dash = false;
   for (auto opt : options) {
      if ( opt.compare("--") == 0 ) {
         has_dash_dash = true;
         break;
      }
   }
   if (!has_dash_dash)
      options.push_back("--");
   options.push_back("--target=wasm32");
   options.push_back("-nostdlib");
   options.push_back("-ffreestanding");
   options.push_back("-fno-builtin");
   options.push_back("-fno-rtti");
   options.push_back("-fno-exceptions");
   options.push_back("-I${Boost_INCLUDE_DIRS}");
   options.push_back("-DBOOST_DISABLE_ASSERTS");
   options.push_back("-DBOOST_EXCEPTION_DISABLE");
   options.push_back("-Wno-everything");
   options.push_back("-std=c++17");
   options.push_back(std::string("-I")+eosio::cdt::whereami::where()+"/../include/libcxx");
   options.push_back(std::string("-I")+eosio::cdt::whereami::where()+"/../include/libc");
   options.push_back(std::string("-I")+eosio::cdt::whereami::where()+"/../include");
   options.push_back(std::string("-I")+eosio::cdt::whereami::where()+"/../../../../../libraries/libc++/libcxx/include");
   options.push_back(std::string("-I")+eosio::cdt::whereami::where()+"/../../../../../libraries/libc/musl/include");
   options.push_back(std::string("-I")+eosio::cdt::whereami::where()+"/../../../../../libraries");
   options.push_back(std::string("-I")+eosio::cdt::whereami::where()+"/../../../../../libraries/boost/include");

   int size = options.size();
   const char** new_argv = new const char*[size];
   for (size_t i=0; i < size; i++)
      new_argv[i] = options[i].c_str();

   CommonOptionsParser opts( size, new_argv, cat, 0 );
   ClangTool ctool(opts.getCompilations(), opts.getSourcePathList());

   get_abigen_ref().set_contract_name(contract_name);
   get_abigen_ref().set_resource_dirs(resource_paths);
   codegen::get().set_contract_name(contract_name);

   EosioMethodMatcher eosio_method_matcher;
   EosioRecordMatcher eosio_record_matcher;
   MatchFinder finder;

   finder.addMatcher(function_decl_matcher, &eosio_method_matcher);
   finder.addMatcher(record_decl_matcher, &eosio_record_matcher);
   finder.addMatcher(class_tmp_matcher, &eosio_record_matcher);

   int tool_run = -1;
   try {
      if (!codegen_only) {
         tool_run = ctool.run(newFrontendActionFactory(&finder).get());
         if (tool_run != 0) {
            std::cout << "abigen error\n";
            return tool_run;
         }
      }
      std::string abi_s;
      get_abigen_ref().to_json().dump(abi_s);
      codegen::get().set_abi(abi_s);
      if (codegen || codegen_only)
         tool_run = ctool.run(newFrontendActionFactory<eosio_codegen_frontend_action>().get());

      std::ofstream output(abidir);
      output << pretty_print(get_abigen_ref().to_json());
      output.close();
   } catch (std::exception& ex) {
      std::cout << ex.what() << "\n";
      tool_run = -1;
   } 
   return tool_run;
}
