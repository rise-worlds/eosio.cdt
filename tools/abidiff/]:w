// Declares clang::SyntaxOnlyAction.
#include "clang/Frontend/FrontendActions.h"
#include "clang/Tooling/CommonOptionsParser.h"
#include "clang/Tooling/Tooling.h"
#include "clang/ASTMatchers/ASTMatchers.h"
#include "clang/ASTMatchers/ASTMatchFinder.h"
#include "clang/AST/DeclCXX.h"
#include "clang/AST/DeclTemplate.h"
#include "clang/AST/Expr.h"
#include "clang/Basic/Builtins.h"
#include "llvm/Support/FileSystem.h"
#include "eosio/utils.hpp"
#include "eosio/gen.hpp"
#include "eosio/whereami/whereami.hpp"
#include "eosio/abi.hpp"

#include <exception>
#include <iostream>
#include <fstream>
#include <sstream>
#include <memory>
#include <set>
#include <map>
#include <chrono>
#include <ctime>

#include <jsoncons/json.hpp>

#include "llvm/Support/CommandLine.h"
using namespace clang::tooling;
using namespace clang::ast_matchers;
using namespace llvm;
using namespace eosio;
using namespace eosio::cdt;
using jsoncons::json;
using jsoncons::ojson;

struct abidiff_exception : public std::exception {
   virtual const char* what() const throw() {
      return "eosio.abidiff fatal error";
   }
} abidiff_ex;


class abidiff {
   private:
      ojson abi_1, abi_2;
      std::string fn_1, fn_2;
   public:
      abidiff( const std::string& fn1, const std::string& fn2) {
         llvm::SmallString<128> _fn1, _fn2;
         if (!llvm::sys::fs::real_path(fn1, _fn1, true)) {
            std::ifstream in(_fn1.str().str());
            fn_1 = _fn1.str().str();
            abi_1 = ojson::parse(in);
         } else {
            std::cerr << "Error, invalid filepath { " << _fn1.str().str() << " }\n";
            throw abidiff_ex;
         }

         if (!llvm::sys::fs::real_path(fn2, _fn2, true)) {
            std::ifstream in(_fn2.str().str());
            fn_2 = _fn2.str().str();
            abi_2 = ojson::parse(in);
         } else {
            std::cerr << "Error, invalid filepath { " << _fn2.str().str() << " }\n";
            throw abidiff_ex;
         }

      }

      void diff_version() {
         if (abi_1["version"].as<std::string>().compare(abi_2["version"].as<std::string>())) {
            std::cout << "< version\n\t";
            std::cout << abi_1["version"].as<std::string>() << "\n";
            std::cout << "> version\n\t";
            std::cout << abi_2["version"].as<std::string>() << "\n";
         }
      }

      void diff_structs() {
         std::set<std::string> diff_set_1, diff_set_2;
         for ( int i=0; i < abi_1["structs"].size(); i++ ) {
         }
            std::cout << abi_1["structs"].at(i)["name"] << "\n";
      }

      void diff() {
         diff_version();
         diff_structs();
      }
#if 0
   ojson struct_to_json( const abi_struct& s ) {
      ojson o;
      o["name"] = s.name;
      o["base"] = s.base;
      o["fields"] = ojson::array();
      for ( auto field : s.fields ) {
         ojson f;
         f["name"] = field.name;
         f["type"] = field.type;
         o["fields"].push_back(f);
      }
      return o;
   }

   ojson variant_to_json( const abi_variant& v ) {
      ojson o;
      o["name"] = v.name;
      o["types"] = ojson::array();
      for ( auto ty : v.types ) {
         o["types"].push_back( ty );
      }
      return o;
   }

   ojson typedef_to_json( const abi_typedef& t ) {
      ojson o;
      o["new_type_name"] = t.new_type_name;
      o["type"]          = t.type;
      return o;
   }

   ojson action_to_json( const abi_action& a ) {
      ojson o;
      o["name"] = a.name;
      o["type"] = a.type;
      o["ricardian_contract"] = a.ricardian_contract;
      return o;
   }

   ojson clause_to_json( const abi_ricardian_clause_pair& clause ) {
      ojson o;
      o["id"] = clause.id;
      o["body"] = clause.body;
      return o;
   }

   ojson table_to_json( const abi_table& t ) {
      ojson o;
      o["name"] = t.name;
      o["type"] = t.type;
      o["index_type"] = "i64";
      o["key_names"] = ojson::array();
      o["key_types"] = ojson::array();
      return o;
   }

   ojson to_json() {
      ojson o;
      o["____comment"] = generate_json_comment();
      o["version"]     = _abi.version;
      o["structs"]     = ojson::array();
      auto remove_suffix = [&]( std::string name ) {
         int i = name.length()-1;
         for (; i >= 0; i--) 
            if ( name[i] != '[' && name[i] != ']' && name[i] != '?' && name[i] != '$' )
               break;
         return name.substr(0,i+1);
      };

      std::set<abi_table> set_of_tables;
      for ( auto t : ctables ) {
         bool has_multi_index = false;
         for ( auto u : _abi.tables ) {
            if (t.type == u.type) {
               has_multi_index = true;
               break;
            }
            set_of_tables.insert(u);
         }
         if (!has_multi_index)
            set_of_tables.insert(t);
      }
      for ( auto t : _abi.tables ) {
         set_of_tables.insert(t);
      }
      
      auto validate_struct = [&]( abi_struct as ) {
         if ( is_builtin_type(as.name) )
            return false;
         for ( auto s : _abi.structs ) {
            for ( auto f : s.fields ) {
               if (as.name == remove_suffix(f.type))
                  return true;
            }
            if ( s.base == as.name )
               return true;
         }
         for ( auto a : _abi.actions ) {
            if ( as.name == a.type )
               return true;
         }
         for( auto t : set_of_tables ) {
            if (as.name == t.type)
               return true;
         }
         for( auto td : _abi.typedefs ) {
            if (as.name == remove_suffix(td.type))
               return true;
         }
         return false;
      };
      
      auto validate_types = [&]( abi_typedef td ) {
         for ( auto as : _abi.structs )
            if (validate_struct(as))
               for ( auto f : as.fields )
                  if ( remove_suffix(f.type) == td.new_type_name )
                     return true;
         for ( auto t : _abi.tables )
            if ( t.type == td.new_type_name )
               return true;
         for ( auto a : _abi.actions )
            if ( a.type == td.new_type_name )
               return true;
         for ( auto _td : _abi.typedefs )
            if ( remove_suffix(_td.type) == td.new_type_name )
               return true;
         return false;
      };

      for ( auto s : _abi.structs ) {
         if (validate_struct(s))
            o["structs"].push_back(struct_to_json(s));
      }
      o["types"]       = ojson::array();
      for ( auto t : _abi.typedefs ) {
         if (validate_types(t))
            o["types"].push_back(typedef_to_json( t ));
      }
      o["actions"]     = ojson::array();
      for ( auto a : _abi.actions ) {
         o["actions"].push_back(action_to_json( a ));
      }
      o["tables"]     = ojson::array();
      for ( auto t : set_of_tables ) {
         o["tables"].push_back(table_to_json( t ));
      }
      o["ricardian_clauses"]  = ojson::array();
      for ( auto rc : _abi.ricardian_clauses ) {
         o["ricardian_clauses"].push_back(clause_to_json( rc ));
      }
      o["variants"]   = ojson::array();
      for ( auto v : _abi.variants ) {
         o["variants"].push_back(variant_to_json( v ));
      }
      o["abi_extensions"]     = ojson::array();
      return o;
   }
#endif
};

int main(int argc, const char **argv) {

   cl::SetVersionPrinter([](llvm::raw_ostream& os) {
        os << "eosio-abidiff version " << ${VERSION_MAJOR} << "." << ${VERSION_MINOR} << "." << ${VERSION_PATCH} << "\n";
  });
   cl::OptionCategory cat("eosio-abidiff", "generates an abi from C++ project input");

   cl::opt<std::string> input_filename1(
      cl::Positional, 
      cl::desc("<input file1> ..."), 
      cl::Required,
      cl::cat(cat));
   cl::opt<std::string> input_filename2(
      cl::Positional, 
      cl::desc("<input file2> ..."), 
      cl::Required,
      cl::cat(cat));

   cl::ParseCommandLineOptions(argc, argv, std::string("eosio-abidiff"));
   try {
      abidiff diff(input_filename1, input_filename2);
      diff.diff();
   } catch ( jsoncons::parse_error& e ) {
      std::cout << e.what() << "\n";
   }
   
   return 0;
}
